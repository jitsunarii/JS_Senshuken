<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style href="https://codepen.io/inwan78/pen/WNJEKeQ.css"></style>
    <style>
      CSS JSResult Skip Results Iframe EDIT ON * {
        margin: 0;
        padding: 0;
      }
      body {
        background-color: blue;
      }

      /*ゲーム画面*/
      #game-screen {
        margin: 0 auto;
      }

      /* 体力バー */
      .health-bar {
        width: 200px;
        height: 20px;
        background-color: grey;
        border: 1px solid #000;
        position: absolute;
        top: 10px;
      }
      #player1-health-bar {
        left: 10px;
      }
      #player2-health-bar {
        right: 10px;
      }
      .health {
        height: 100%;
        background-color: green;
      }

      /* 勝利メッセージ */
      #win-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 32px;
        color: white;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="player1-health-bar" class="health-bar">
      <div id="player1-health" class="health" style="width: 100%"></div>
    </div>
    <div id="player2-health-bar" class="health-bar">
      <div id="player2-health" class="health" style="width: 100%"></div>
    </div>
      </div>
      <div id="win-message">Player 1 WIN</div>
    </div>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.3.7/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@pixi/sound@4.0.4/dist/pixi-sound.js"></script>
    <script src="./chara.js"></script>
    <script src="./code.js"></script>
    <script>
      //設定用
      const Config = {
        Screen: {
          Width: 512,
          Height: 512,
          BackGroundColor: "black",
        },
        Keys: {
          Up: "w",
          Right: "d",
          Down: "s",
          Left: "a",
          A: "t",
          B: "r",
          Start: "Enter",
          Up2: "ArrowUp",
          Right2: "ArrowRight",
          Down2: "ArrowDown",
          Left2: "ArrowLeft",
          A2: "n",
          B2: "m",
        },
      };

      //読みこむデータリスト(名前：ファイルパス)
      const Resource = {
        Player: "./character.bmp",
        Bullet: "./hadoken.gif",
        BGM:"./Fight_BGM.mp3", // BGMの追加
        SE:"./hadoken.wav"
      };

      //上のリストを読み込みやすい形にする
      const assets = [];
      for (let key in Resource) {
        assets.push(Resource[key]);
      }
        let core;
        let inputManager;
      //  core; //ゲームの基幹プログラム用の変数

      //ブラウザの読み込みが完了したら実行
      window.onload = () => {
        //設定した画面サイズでcoreを作成
        core = new Game(
          Config.Screen.Width,
          Config.Screen.Height,
          Config.Screen.BackGroundColor
        );
 inputManager = new InputManager();
        //データのロード
        core.preload(assets);

        //読み込み完了でタイトルシーンに切り替え
///////////////////////////////////変更１/////////////////////////////////////
        core.onload =function(){
          core.replaceScene(new TitleScene());
        };
      };

      let player;
      let player2;
      //体力バーの初期設定
      let player1Health = 100;
      let player2Health = 100;

      // ゲームオーバーフラグ
      let gameOver = false;

      // 体力バーの更新関数
      function updateHealthBar(player, health) {
         const healthBar = document.getElementById(`${player}-health`);
        healthBar.style.width = `${health}%`;

        // 体力が50%未満になった場合、色を赤に変更
        if (health < 50) {
          healthBar.style.backgroundColor = "red";
        } else {
          healthBar.style.backgroundColor = "green";
        }
      }

      // 体力を減らす関数
      function reduceHealth(player, damage) {
        if (player === "player1") {
          player1Health = Math.max(player1Health - damage, 0);
          updateHealthBar("player1", player1Health);
          if (player1Health === 0) {
            gameOver = true;
            displayWinMessage("Player 2 WIN"); // Player 2の勝利メッセージを表示
          }
        } else if (player === "player2") {
          player2Health = Math.max(player2Health - damage, 0);
          updateHealthBar("player2", player2Health);
          if (player2Health === 0) {
            gameOver = true;
            displayWinMessage("Player 1 WIN");
          }
        }
      }
// 勝利メッセージを表示する関数
      function displayWinMessage(message) {
        const winMessage = document.getElementById("win-message");
        winMessage.innerText = message;
        winMessage.style.display = "block";
      }

      //初期状態の体力バーを設定
      updateHealthBar("player1", player1Health);
      updateHealthBar("player2", player2Health);
      ///////////////タイトルシーン//////////////////////////////////////////////////
      class TitleScene extends Container {
        constructor() {
          super();

          const style = new PIXI.TextStyle({
            fontFamily: "sans-serif",
            fontSize: 50,
            fill: 0xffffff,
            fontWeight: "bold",
            stroke: "red", //縁取りの色
            strokeThickness: 4, //縁取りの太さ
          });

          const p = new PIXI.Text("FUKUOKAA", style);
          p.anchor.set(0.5);
          p.position.set(256, 50);
          this.addChild(p);

          const p_p = new PIXI.Text("FIGHTER", style);
          p_p.anchor.set(0.5);
          p_p.position.set(256, 100);
          this.addChild(p_p);
        }
     update(delta) {
          // Config.Keys.Startが押されたらメインシーンに切り替え
         if (inputManager.checkButton(1, "Start") === inputManager.keyStatus.DOWN) {
            core.replaceScene(new MainScene());
            ;
          }
        }
      }
      ///////////////メインシーン//////////////////////////////////////////////////
      class MainScene extends Container {
        constructor() {
          super();

          this.player = new Player(32, 32);
          this.addChild(this.player);

          this.player2 = new Player2(32, 32);
          this.addChild(this.player2);

          this.shootImages = [];

          this.shootSpeed = 5; // 弾の速度

          PIXI.sound.play(Resource.BGM,{loop:true});
        }
        update(delta) {
          if (gameOver) return; // ゲームオーバーなら更新しない
          super.update(delta);

          // Aボタンが押されたときの処理
          if (
            inputManager.checkButton(1, "A") === inputManager.keyStatus.DOWN
          ) {
            const shootImage = new PIXI.Sprite(
              PIXI.Texture.from(Resource.Bullet)
            );
            shootImage.width = 100;
            shootImage.height = 100;
            shootImage.position.set(
              this.player.x - this.player.width,
              this.player.y - 70
            );
            shootImage.directionX = Math.sign(this.player2.x - this.player.x); // プレイヤー2の方向に飛ばす
            shootImage.shooter = "player1";
            this.addChild(shootImage);
            this.shootImages.push(shootImage);
            PIXI.sound.play(Resource.SE);
            // プレイヤー2にダメージを与える
            // reduceHealth("player2", 10);
          }

          // A2ボタンが押されたときの処理
          if (
            inputManager.checkButton(2, "A2") === inputManager.keyStatus.DOWN
          ) {
            const shootImage = new PIXI.Sprite(
              PIXI.Texture.from(Resource.Bullet)
            );
            shootImage.width = 100;
            shootImage.height = 100;
            shootImage.position.set(
              this.player2.x - this.player2.width - 36,
              this.player2.y - 70
            );
            shootImage.directionX = -Math.sign(this.player2.x - this.player.x); // プレイヤー1の方向に飛ばす
            shootImage.shooter = "player2";
            this.addChild(shootImage);
            this.shootImages.push(shootImage);
            PIXI.sound.play(Resource.SE);
          }

          // 画像が表示されている場合の移動処理
          for (let i = this.shootImages.length - 1; i >= 0; i--) {
            const shootImage = this.shootImages[i];
            shootImage.x += shootImage.directionX * this.shootSpeed;

            // 当たり判定のチェック
            if (
              shootImage.shooter === "player1" &&
              this.checkCollision(shootImage, this.player2)
            ) {
              reduceHealth("player2", 10);
              this.removeChild(shootImage);
              this.shootImages.splice(i, 1);
              continue;
            } else if (
              shootImage.shooter === "player2" &&
              this.checkCollision(shootImage, this.player)
            ) {
              reduceHealth("player1", 10);
              this.removeChild(shootImage);
              this.shootImages.splice(i, 1);
              continue;
            }
            // 画面の端まで到達したら非表示にする
            if (shootImage.x < 0 || shootImage.x > Config.Screen.Width) {
              this.removeChild(shootImage);
              this.shootImages.splice(i, 1);
            }
          }
        }
        // 当たり判定の関数
        checkCollision(bullet, player) {
          const bulletBounds = bullet.getBounds();
          const playerBounds = player.getBounds();
          return (
            bulletBounds.x < playerBounds.x + playerBounds.width &&
            bulletBounds.x + bulletBounds.width > playerBounds.x &&
            bulletBounds.y < playerBounds.y + playerBounds.height &&
            bulletBounds.y + bulletBounds.height > playerBounds.y
          );
        }
      }
      ///////////////全キャラクター共通基本クラス////////////////////////////////////
      class Actor extends EnchantSprite {
        constructor(w, h) {
          super(w, h);
          this.anchor.set(0.5, 1); //Y座標の中心は足元に
          this.vx = 0;
          this.vy = 0;
          this.fpX = 0; //小数点以下保存用
          this.fpY = 0;

          //アニメーション用
          this.animation = {
            isPlayAuto: false,
            frameNumbers: [],
            intervals: [],
            type: null,
            index: 0,
            count: 0,
            data: {},
          };
        }
        //アニメーション切り替えプログラム
        changeAnimationPattern(type) {
          const anim = this.animation;
          anim.frameNumbers = anim.data[type].frameNumbers;
          anim.intervals = anim.data[type].intervals;
          anim.type = type;
          anim.index = 0;
          anim.count = 0;
          this.frameNumber = anim.frameNumbers[0];
        }
        //キャラの座標から小数点を抜く
        posRemoveFractionalPart() {
          const x = this.x | 0; //小数点以下を切り捨て
          this.fpX = this.x - x;
          this.x = x;
          const y = this.y | 0;
          this.fpY = this.y - y;
          this.y = y;
        }
        //キャラの座標に小数点以下を戻す
        posRestoreFractionalPart() {
          this.x += this.fpX;
          this.y += this.fpY;
        }
        update(delta) {
          if (gameOver) return;
          super.update(delta);
          //自動アニメーション処理
          const anim = this.animation;
          if (anim.isPlayAuto && ++anim.count > anim.intervals[anim.index]) {
            if (++anim.index >= anim.intervals.length) {
              anim.index = 0;
            }
            this.frameNumber = anim.frameNumbers[anim.index];
            anim.count = 0;
          }
        }
      }

      //////////////////////プレイヤークラス////////////////////////////////////
      class Player extends Actor {
        constructor(w, h) {
          super(w, h);
          this.image = core.resources[Resource.Player].texture;
          this.position.set(
            Config.Screen.Width * 0.25,
            Config.Screen.Height * 0.75
          );
          this.maxSpeed = 4;
          this.acceleration = 0.24;
          this.friction = 0.08;
          this.isOnGround = true;
          this.gravity = 0.3;

          this.projectiles = [];

          this.animation.data = {
            stand: {
              frameNumbers: [16],
              intervals: [100],
            },
            walk: {
              frameNumbers: [15, 16, 17, 16],
              intervals: [8, 8, 8, 8],
            },
            jump: {
              frameNumbers: [16],
              intervals: [100],
            },
            fall: {
              frameNumbers: [16],
              intervals: [100],
            },
          };
          this.animation.type = "stand";
          this.animation.isPlayAuto = true;
        }
        update(delta) {
          if (gameOver) return;
          super.update(delta);
          this.posRestoreFractionalPart(); //一番最初に小数点を戻す

          const btn = inputManager.checkButton(1, "Up");
          if (btn == inputManager.keyStatus.DOWN) {
            if (this.isOnGround) {
              this.vy = -8;
              this.changeAnimationPattern("jump");
            }
          }
          if (btn == inputManager.keyStatus.RELEASE) {
            if (this.vy < 0) {
              this.vy /= 2;
            }
          }
          this.isOnGround = false;
          this.vy += this.gravity;
          this.y += this.vy;
          if (this.y > Config.Screen.Height * 0.75) {
            this.y = Config.Screen.Height * 0.75;
            this.vy = 0;
            this.isOnGround = true;
            if (this.animation.type != "walk") {
              this.changeAnimationPattern("walk");
            }
          } else if (this.vy > 0 && this.animation.type != "fall") {
            this.changeAnimationPattern("fall");
          }

          switch (inputManager.checkDirection(1)) {
            case inputManager.keyDirections.RIGHT:
              if (this.isOnGround && this.vx == 0) {
                this.changeAnimationPattern("walk");
              }
              this.scale.x = 1;
              this.vx += this.acceleration;
              this.vx = this.vx > this.maxSpeed ? this.maxSpeed : this.vx;
              break;
            case inputManager.keyDirections.LEFT:
              if (this.isOnGround && this.vx == 0) {
                this.changeAnimationPattern("walk");
              }
              this.scale.x = 1;
              this.vx -= this.acceleration;
              this.vx = this.vx < -this.maxSpeed ? -this.maxSpeed : this.vx;
              break;
            case inputManager.keyDirections.DOWN:
              break;
            default:
              break;
          }

          //摩擦的なもの(減速させる)
          if (this.vx > this.friction) {
            this.vx -= this.friction;
          } else if (this.vx < -this.friction) {
            this.vx += this.friction;
          } else {
            this.vx = 0;
            if (this.isOnGround) {
              this.changeAnimationPattern("stand");
            }
          }
          this.x += this.vx;
          this.posRemoveFractionalPart(); //一番最後に小数点を取り除く
        }
      }

      ///////////////プレイヤー2クラス////////////////////////////////////
      class Player2 extends Actor {
        constructor(w, h) {
          super(w, h);
          this.image = core.resources[Resource.Player].texture;
          this.position.set(
            Config.Screen.Width * 0.75,
            Config.Screen.Height * 0.75
          );
          this.maxSpeed = 4;
          this.acceleration = 0.24;
          this.friction = 0.08;
          this.isOnGround = true;
          this.gravity = 0.3;

          this.animation.data = {
            stand: {
              frameNumbers: [46],
              intervals: [100],
            },
            walk: {
              frameNumbers: [45, 46, 47, 46],
              intervals: [8, 8, 8, 8],
            },
            jump: {
              frameNumbers: [46],
              intervals: [100],
            },
            fall: {
              frameNumbers: [46],
              intervals: [100],
            },
          };
          this.animation.type = "stand";
          this.animation.isPlayAuto = true;
        }
        update(delta) {
          if (gameOver) return;
          super.update(delta);
          this.posRestoreFractionalPart(); //一番最初に小数点を戻す

          const btn = inputManager.checkButton(2, "Up2");
          if (btn == inputManager.keyStatus.DOWN) {
            if (this.isOnGround) {
              this.vy = -8;
              this.changeAnimationPattern("jump");
            }
          }
          if (btn == inputManager.keyStatus.RELEASE) {
            if (this.vy < 0) {
              this.vy /= 2;
            }
          }
          this.isOnGround = false;
          this.vy += this.gravity;
          this.y += this.vy;
          if (this.y > Config.Screen.Height * 0.75) {
            this.y = Config.Screen.Height * 0.75;
            this.vy = 0;
            this.isOnGround = true;
            if (this.animation.type != "walk") {
              this.changeAnimationPattern("walk");
            }
          } else if (this.vy > 0 && this.animation.type != "fall") {
            this.changeAnimationPattern("fall");
          }

          switch (inputManager.checkDirection(2)) {
            case inputManager.keyDirections.RIGHT:
              if (this.isOnGround && this.vx == 0) {
                this.changeAnimationPattern("walk");
              }
              this.scale.x = 1;
              this.vx += this.acceleration;
              this.vx = this.vx > this.maxSpeed ? this.maxSpeed : this.vx;
              break;
            case inputManager.keyDirections.LEFT:
              if (this.isOnGround && this.vx == 0) {
                this.changeAnimationPattern("walk");
              }
              this.scale.x = 1;
              this.vx -= this.acceleration;
              this.vx = this.vx < -this.maxSpeed ? -this.maxSpeed : this.vx;
              break;
            case inputManager.keyDirections.DOWN:
              break;
            default:
              break;
          }

          //摩擦的なもの(減速させる)
          if (this.vx > this.friction) {
            this.vx -= this.friction;
          } else if (this.vx < -this.friction) {
            this.vx += this.friction;
          } else {
            this.vx = 0;
            if (this.isOnGround) {
              this.changeAnimationPattern("stand");
            }
          }
          this.x += this.vx;
          this.posRemoveFractionalPart(); //一番最後に小数点を取り除く
        }
      }

    </script>
  </body>
</html>
