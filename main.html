<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style href="https://codepen.io/inwan78/pen/WNJEKeQ.css"></style>
    <style>
      CSS JSResult Skip Results Iframe EDIT ON * {
        margin: 0;
        padding: 0;
      }
      body {
        background-color: blue;
      }

      /*ゲーム画面*/
      #game-screen {
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.3.7/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@pixi/sound@4.0.4/dist/pixi-sound.js"></script>
    <script src="./chara.js"></script>
    <script src="./code.js"></script>
    <script>
      //設定用
      const Config = {
        Screen: {
          Width: 512,
          Height: 512,
          BackGroundColor: "black",
        },
        Keys: {
          Up: "w",
          Right: "d",
          Down: "s",
          Left: "a",
          A: "t",
          B: "r",
          Start: "Enter",
          Up2: "ArrowUp",
          Right2: "ArrowRight",
          Down2: "ArrowDown",
          Left2: "ArrowLeft",
          A2: "n",
          B2: "m",
        },
      };

      //読みこむデータリスト(名前：ファイルパス)
      const Resource = {
        Player: "./character.bmp",
        Bullet: "./2024-05-13 23.28.32（2）.png",
      };

      //上のリストを読み込みやすい形に変えてます
      const assets = [];
      for (let key in Resource) {
        assets.push(Resource[key]);
      }

      let core; //ゲームの基幹プログラム用の変数
      let inputManager;

      //ブラウザの読み込みが完了したら実行されます
      window.onload = () => {
        //設定した画面サイズでcoreを作成
        core = new Game(
          Config.Screen.Width,
          Config.Screen.Height,
          Config.Screen.BackGroundColor
        );
        inputManager = new InputManager();

        //データのロード
        core.preload(assets);

        //読み込み完了でメインシーンに切り替わります
        core.onload = () => {
          core.replaceScene(new MainScene());
        };
      };

      let player;
      let player2;

      ///////////////メインシーン//////////////////////////////////////////////////s
      class MainScene extends Container {
        constructor() {
          super();

          this.player = new Player(32, 32);
          this.addChild(this.player);

          this.player2 = new Player2(32, 32);
          this.addChild(this.player2);

          this.shootImages = [];

          this.shootSpeed = 5; // 弾の速度
        }

        update(delta) {
          super.update(delta);

          // Aボタンが押されたときの処理
          if (
            inputManager.checkButton(1, "A") === inputManager.keyStatus.DOWN
          ) {
            const shootImage = new PIXI.Sprite(
              PIXI.Texture.from(Resource.Bullet)
            );
            shootImage.position.set(
              this.player.x + this.player.width,
              this.player.y
            );
            shootImage.directionX = Math.sign(this.player2.x - this.player.x); // プレイヤー2の方向に飛ばす
            this.addChild(shootImage);
            this.shootImages.push(shootImage);
          }

          // A2ボタンが押されたときの処理
          if (
            inputManager.checkButton(2, "A2") === inputManager.keyStatus.DOWN
          ) {
            const shootImage = new PIXI.Sprite(
              PIXI.Texture.from(Resource.Bullet)
            );
            shootImage.position.set(
              this.player2.x - this.player2.width,
              this.player2.y
            );
            shootImage.directionX = -Math.sign(this.player2.x - this.player.x); // プレイヤー1の方向に飛ばす
            this.addChild(shootImage);
            this.shootImages.push(shootImage);
          }

          // 画像が表示されている場合の移動処理
          for (let i = this.shootImages.length - 1; i >= 0; i--) {
            const shootImage = this.shootImages[i];
            shootImage.x += shootImage.directionX * this.shootSpeed;

            // 画面の端まで到達したら非表示にする
            if (shootImage.x < 0 || shootImage.x > Config.Screen.Width) {
              this.removeChild(shootImage);
              this.shootImages.splice(i, 1);
            }
          }
        }
      }
      ///////////////全キャラクター共通基本クラス////////////////////////////////////
      class Actor extends EnchantSprite {
        constructor(w, h) {
          super(w, h);
          this.anchor.set(0.5, 1); //Y座標の中心は足元に
          this.vx = 0;
          this.vy = 0;
          this.fpX = 0; //小数点以下保存用
          this.fpY = 0;

          //アニメーション用
          this.animation = {
            isPlayAuto: false,
            frameNumbers: [],
            intervals: [],
            type: null,
            index: 0,
            count: 0,
            data: {},
          };
        }
        //アニメーション切り替えプログラム
        changeAnimationPattern(type) {
          const anim = this.animation;
          anim.frameNumbers = anim.data[type].frameNumbers;
          anim.intervals = anim.data[type].intervals;
          anim.type = type;
          anim.index = 0;
          anim.count = 0;
          this.frameNumber = anim.frameNumbers[0];
        }
        //キャラの座標から小数点を抜く
        posRemoveFractionalPart() {
          const x = this.x | 0; //小数点以下を切り捨て
          this.fpX = this.x - x;
          this.x = x;
          const y = this.y | 0;
          this.fpY = this.y - y;
          this.y = y;
        }
        //キャラの座標に小数点以下を戻す
        posRestoreFractionalPart() {
          this.x += this.fpX;
          this.y += this.fpY;
        }
        update(delta) {
          super.update(delta);
          //自動アニメーション処理
          const anim = this.animation;
          if (anim.isPlayAuto && ++anim.count > anim.intervals[anim.index]) {
            if (++anim.index >= anim.intervals.length) {
              anim.index = 0;
            }
            this.frameNumber = anim.frameNumbers[anim.index];
            anim.count = 0;
          }
        }
      }

      ///////////////プレイヤークラス////////////////////////////////////
      class Player extends Actor {
        constructor(w, h) {
          super(w, h);
          this.image = core.resources[Resource.Player].texture;
          this.position.set(
            Config.Screen.Width * 0.25,
            Config.Screen.Height * 0.75
          );
          this.maxSpeed = 4;
          this.acceleration = 0.24;
          this.friction = 0.08;
          this.isOnGround = true;
          this.gravity = 0.3;

          this.projectiles = [];

          this.animation.data = {
            stand: {
              frameNumbers: [16],
              intervals: [100],
            },
            walk: {
              frameNumbers: [15, 16, 17, 16],
              intervals: [8, 8, 8, 8],
            },
            jump: {
              frameNumbers: [16],
              intervals: [100],
            },
            fall: {
              frameNumbers: [16],
              intervals: [100],
            },
          };
          this.animation.type = "stand";
          this.animation.isPlayAuto = true;
        }
        update(delta) {
          super.update(delta);
          this.posRestoreFractionalPart(); //一番最初に小数点を戻す

          const btn = inputManager.checkButton(1, "Up");
          if (btn == inputManager.keyStatus.DOWN) {
            if (this.isOnGround) {
              this.vy = -8;
              this.changeAnimationPattern("jump");
            }
          }
          if (btn == inputManager.keyStatus.RELEASE) {
            if (this.vy < 0) {
              this.vy /= 2;
            }
          }
          this.isOnGround = false;
          this.vy += this.gravity;
          this.y += this.vy;
          if (this.y > Config.Screen.Height * 0.75) {
            this.y = Config.Screen.Height * 0.75;
            this.vy = 0;
            this.isOnGround = true;
            if (this.animation.type != "walk") {
              this.changeAnimationPattern("walk");
            }
          } else if (this.vy > 0 && this.animation.type != "fall") {
            this.changeAnimationPattern("fall");
          }

          switch (inputManager.checkDirection(1)) {
            case inputManager.keyDirections.RIGHT:
              if (this.isOnGround && this.vx == 0) {
                this.changeAnimationPattern("walk");
              }
              this.scale.x = 1;
              this.vx += this.acceleration;
              this.vx = this.vx > this.maxSpeed ? this.maxSpeed : this.vx;
              break;
            case inputManager.keyDirections.LEFT:
              if (this.isOnGround && this.vx == 0) {
                this.changeAnimationPattern("walk");
              }
              this.scale.x = 1;
              this.vx -= this.acceleration;
              this.vx = this.vx < -this.maxSpeed ? -this.maxSpeed : this.vx;
              break;
            case inputManager.keyDirections.DOWN:
              break;
            default:
              break;
          }

          //摩擦的なもの(減速させる)
          if (this.vx > this.friction) {
            this.vx -= this.friction;
          } else if (this.vx < -this.friction) {
            this.vx += this.friction;
          } else {
            this.vx = 0;
            if (this.isOnGround) {
              this.changeAnimationPattern("stand");
            }
          }
          this.x += this.vx;

          // 弾の更新
          // if (this.projectiles) {
          //   this.projectiles.forEach((projectile) => projectile.update(delta));
          //   this.projectiles = this.projectiles.filter(
          //     (projectile) => !projectile.isDestroyed
          //   );
          // }

          this.posRemoveFractionalPart(); //一番最後に小数点を取り除く
        }
        // shoot() {
        //   const direction = this.scale.x; // プレイヤーの向きに応じて弾の方向を設定
        //   let projectile = new Projectile(this.x, this.y, direction);
        //   this.projectiles.push(projectile);
        // }
      }

      ///////////////プレイヤー2クラス////////////////////////////////////
      class Player2 extends Actor {
        constructor(w, h) {
          super(w, h);
          this.image = core.resources[Resource.Player].texture;
          this.position.set(
            Config.Screen.Width * 0.75,
            Config.Screen.Height * 0.75
          );
          this.maxSpeed = 4;
          this.acceleration = 0.24;
          this.friction = 0.08;
          this.isOnGround = true;
          this.gravity = 0.3;

          this.animation.data = {
            stand: {
              frameNumbers: [46],
              intervals: [100],
            },
            walk: {
              frameNumbers: [45, 46, 47, 46],
              intervals: [8, 8, 8, 8],
            },
            jump: {
              frameNumbers: [46],
              intervals: [100],
            },
            fall: {
              frameNumbers: [46],
              intervals: [100],
            },
          };
          this.animation.type = "stand";
          this.animation.isPlayAuto = true;
        }
        update(delta) {
          super.update(delta);
          this.posRestoreFractionalPart(); //一番最初に小数点を戻す

          const btn = inputManager.checkButton(2, "Up2");
          if (btn == inputManager.keyStatus.DOWN) {
            if (this.isOnGround) {
              this.vy = -8;
              this.changeAnimationPattern("jump");
            }
          }
          if (btn == inputManager.keyStatus.RELEASE) {
            if (this.vy < 0) {
              this.vy /= 2;
            }
          }
          this.isOnGround = false;
          this.vy += this.gravity;
          this.y += this.vy;
          if (this.y > Config.Screen.Height * 0.75) {
            this.y = Config.Screen.Height * 0.75;
            this.vy = 0;
            this.isOnGround = true;
            if (this.animation.type != "walk") {
              this.changeAnimationPattern("walk");
            }
          } else if (this.vy > 0 && this.animation.type != "fall") {
            this.changeAnimationPattern("fall");
          }

          switch (inputManager.checkDirection(2)) {
            case inputManager.keyDirections.RIGHT:
              if (this.isOnGround && this.vx == 0) {
                this.changeAnimationPattern("walk");
              }
              this.scale.x = 1;
              this.vx += this.acceleration;
              this.vx = this.vx > this.maxSpeed ? this.maxSpeed : this.vx;
              break;
            case inputManager.keyDirections.LEFT:
              if (this.isOnGround && this.vx == 0) {
                this.changeAnimationPattern("walk");
              }
              this.scale.x = 1;
              this.vx -= this.acceleration;
              this.vx = this.vx < -this.maxSpeed ? -this.maxSpeed : this.vx;
              break;
            case inputManager.keyDirections.DOWN:
              break;
            default:
              break;
          }

          //摩擦的なもの(減速させる)
          if (this.vx > this.friction) {
            this.vx -= this.friction;
          } else if (this.vx < -this.friction) {
            this.vx += this.friction;
          } else {
            this.vx = 0;
            if (this.isOnGround) {
              this.changeAnimationPattern("stand");
            }
          }
          this.x += this.vx;
          this.posRemoveFractionalPart(); //一番最後に小数点を取り除く
        }
      }
    </script>
  </body>
</html>
